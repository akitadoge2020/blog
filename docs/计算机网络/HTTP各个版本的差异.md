# HTTP各个版本的差异

## HTTP1.0

### 无法复用连接

HTTP1.0为每个请求单独建立[TCP连接](./TCP协议.md)。

<img src="https://penguinbucket.obs.cn-southwest-2.myhuaweicloud.com/img/image-20220604101540054.png" alt="image-20220604101540054" style="zoom: 80%;" />

由于每个请求都是独立的连接，因此会带来下面的问题：

1. 连接的建立和销毁都会占用服务器和客户端的资源，造成内存资源的浪费
2. 连接的建立和销毁都会消耗时间，造成响应时间的浪费
3. 无法充分利用带宽，造成带宽资源的浪费

> TCP协议的特点是「慢启动」，即一开始传输的数据量少，一段时间之后达到传输的峰值。而上面这种做法，会导致大量的请求在TCP达到传输峰值前就被销毁了。

### 队头阻塞

HTTP1.0规定下一个请求必须在前一个请求响应到达之后才能发送。

<img src="https://penguinbucket.obs.cn-southwest-2.myhuaweicloud.com/img/image-20220604102453653.png" alt="image-20220604102453653" style="zoom:80%;" />



## HTTP1.1

### 长连接

为了解决HTTP1.0的问题，**HTTP1.1默认开启长连接**，即让同一个TCP连接服务于多个请求-响应。

<img src="https://penguinbucket.obs.cn-southwest-2.myhuaweicloud.com/img/image-20220604102724413.png" alt="image-20220604102724413" style="zoom:80%;" />

在这种情况下，多次请求响应可以共享同一个TCP连接，这不仅减少了TCP的握手和挥手时间，同时可以充分利用TCP「慢启动」的特点，有效的利用带宽。

::: tip 小知识

实际上，在HTTP1.0后期，虽然没有官方标准，但开发者们慢慢形成了一个共识：

只要请求头中包含`Connection: keep-alive`，就表示客户端希望开启长连接，希望服务器响应后不要关闭TCP连接。如果服务器认可这一行为，即可保持TCP连接。

:::

我们在开发者工具中Network里可以看到，有相同的`Connection ID`表示这些请求使用的是同一个TCP连接。

当需要的时候，任何一方都可以关闭TCP连接，关闭的情况主要有三种：

1. 客户端在某一次请求中设置了`Connection: close`，服务器收到此请求后，响应结束后立即关闭TCP连接
2. 在没有请求时，客户端会不断对服务器进行心跳检测（一般每隔1秒）。一旦心跳检测停止，服务器立即关闭TCP连接
3. 当客户端长时间没有新的请求到达服务器，服务器会主动关闭TCP。运维人员可以设置该时间。

### 管道化和队头阻塞

HTTP1.1允许在响应到达之前发送下一个请求，这样可以大幅缩减带宽限制时间

<img src="https://penguinbucket.obs.cn-southwest-2.myhuaweicloud.com/img/image-20220604105403597.png" alt="image-20220604105403597" style="zoom:80%;" />

由于多个请求使用的是同一个TCP连接，**服务器必须按照请求到达的顺序进行响应**，否则客户端无法知晓服务器的响应对应的是哪个请求。

于是，这就导致了一些后发出的请求，无法在处理完成后响应，产生了等待的时间，而这段时间的带宽可能是空闲的，这就造成了带宽的浪费。

队头阻塞虽然**发生在服务器**，但这个问题的根源是客户端无法知晓服务器的响应是针对哪个请求的。

正是由于存在队头阻塞，我们常常使用下面的手段进行优化：

- 通过减少文件数量，从而减少队头阻塞的几率
- 通过开辟多个TCP连接，实现真正的、有缺陷的并行传输

浏览器会根据情况，为打开的页面自动开启TCP连接，对于同一个域名的连接最多6个。如果要突破这个限制，就需要把资源放到不同的域中。

**然而，管道化并非一个成功的模型，它带来的队头阻塞造成非常多的问题，所以现代浏览器默认是关闭这种模式的**

### 为什么队头阻塞无法解决？

本质原因就是HTTP协议在传输过程中必须是传输完整的报文（由行、头、体组成），不能分割。

## HTTP2.0

HTTP2.0新增了Binary Framing（二进制分帧）。

<img src="https://penguinbucket.obs.cn-southwest-2.myhuaweicloud.com/img/image-20220604112546003.png" alt="image-20220604112546003" style="zoom: 50%;" />

### 二进制分帧

HTTP2.0可以允许以更小的单元传输数据，每个传输单元称之为**帧**，而每一个请求或响应的完整数据称之为**流**，每个流有自己的编号，每个帧会记录所属的流。

比如，服务器连续接到了客户端的两个请求，一个请求JS、一个请求CSS，两个文件如下：

```javascript
function a () {}
function b () {}
```

```css
.container {}
.list {}
```

最终形成的帧可能如下：

![image-20220604112936753](https://penguinbucket.obs.cn-southwest-2.myhuaweicloud.com/img/image-20220604112936753.png)

这样就真正的解决了共享TCP连接时的队头阻塞问题，实现了真正的**多路复用**。

不仅如此，由于传输时是以帧为单元传输的，无论是响应还是请求，都可以实现并发处理，即不同的传输可以交替进行。

由于进行了分帧，还可以设置传输优先级。

### 头部压缩

HTTP2.0之前，所有的消息头都是以字符的形式完整传输的。

可实际上，大部分头部信息都有很多的重复。

为了解决这一问题，HTTP2.0使用头部压缩来减少消息头的体积。

![image-20220604120604118](https://penguinbucket.obs.cn-southwest-2.myhuaweicloud.com/img/image-20220604120604118.png)

对于两张表都没有的头部，则使用Huffman编码压缩后进行传输，同时添加到动态表中。

### 服务器推

HTTP2.0允许在客户端没有主动请求的情况下，服务器预先把资源推送给客户端。

当客户端后续需要请求该资源时，则自动从之前推送的资源中寻找。

## 总结

### HTTP1.0、HTTP1.1、HTTP2.0的区别：

首先说HTTP1.0

它的特点是每次请求和响应完毕后都会销毁TCP连接，同时规定前一个响应完成后才能发送下一个请求。这样做有两个问题：

1. 无法复用连接

   每次请求都要创建新的TCP连接，完成三次握手和四次挥手，网络利用率低。

2. 队头阻塞

   如果前一个请求被某种原因阻塞了，会导致后续请求无法发送。

然后是HTTP1.1

HTTP1.1是HTTP1.0的改进版，它做出了以下改进：

1. 长连接

   HTTP1.1允许在请求时增加请求头`Connection: keep-alive`，这样便允许后续的客户端请求在一段时间内复用之前的TCP连接。

2. 管道化

   基于长连接的基础，管道化可以不等第一个请求响应继续发送后面的请求，但响应的顺序还是按照请求的顺序返回。

3. 缓存处理

   新增响应头 Cache-Control，用于实现客户端缓存。

4. [断点传输](./断点续传.md)

   在上传/下载资源时，如果资源过大，将其分割为多个部分，分别上传/下载，如果遇到网络故障，可以从已经上传/下载好的地方继续请求，不用从头开始，提高效率

最后是HTTP2.0

HTTP2.0进一步优化了传输效率，它主要有以下改进：

1. 二进制分帧

   将传输的消息分为更小的二进制帧，每帧有自己的标识序号，即便被随意打乱也能在另一端正确组装

2. 多路复用

   基于二进制分帧，在同一域名下所有访问都是从同一个 tcp 连接中走，并且不再有队头阻塞问题，也无须遵守响应顺序

3. 头部压缩

   HTTP2.0通过字典的形式，将头部中的常见信息替换为更少的字符，极大的减少了头部的数据量，从而实现更小的传输量

4. 服务器推

   HTTP2.0允许服务器直接推送消息给客户端，无须客户端明确的请求