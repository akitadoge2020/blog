# 浏览器工作原理

在深入了解浏览器工作原理之前，需要先了解几个概念。

## 概念

### JS、JS执行引擎和浏览器

- JS：一门计算机语言，提供了表达程序逻辑的语法和实现基本功能的API
- JS执行引擎：宿主环境的一个功能模块，负责解析执行JS代码
- 浏览器：JS代码的运行环境，也称之为宿主环境

它们的关系如图：

![image-20220503154622020](https://penguinbucket.obs.cn-southwest-2.myhuaweicloud.com/img/image-20220503154622020.png)

### 进程和线程

- 进程：是操作系统分配资源的基本单位，**简单来说，进程可以理解为一个正在运行的应用程序**。在一个应用程序运行时，需要使用内存和CPU资源，这些资源需要向操作系统申请，操作系统会以进程为单位分配这些资源。一个应用程序要运行，就至少要有一个进程启动。**一个进程就代表着一块独立于其他进程的内存空间**。进程最大的特点就是独立，一个进程不能随意访问其他进程的资源，这就保证了多个程序在操作系统上运行互不干扰。

![image-20220503161911961](https://penguinbucket.obs.cn-southwest-2.myhuaweicloud.com/img/image-20220503161911961.png)

- 线程：是进程的一个执行单位，也就是说，**线程是跑在进程里面的**。一个进程里可能有一个或多个线程，而一个线程只能隶属于一个进程。线程和线程之间相互独立，但可以共享资源。

![image-20220503162941766](https://penguinbucket.obs.cn-southwest-2.myhuaweicloud.com/img/image-20220503162941766.png)

## 浏览器的多进程架构

在应用程序中，为了满足功能需要，启动的进程会创建另一个新的进程来处理其他任务，这些被创建出来的进程一样拥有独立的内存空间，与原来的进程互不干扰。如果这些进程之间需要通信，可以通过IPC机制（Inter Process Communication）来进行。

![image-20220503163949888](https://penguinbucket.obs.cn-southwest-2.myhuaweicloud.com/img/image-20220503163949888.png)

不同的浏览器使用不同的架构，它可以是单进程多线程应用程序，也可以是基于IPC通信的多线程应用程序。

我们主要以Chrome为例，介绍浏览器的多进程架构。

在Chrome中，主要的进程有4个：

- 浏览器进程 (Browser Process)：负责浏览器的tab的前进、后退、地址栏、书签栏的工作和处理浏览器的一些不可见的底层操作，比如网络请求和文件访问。
- 渲染进程 (Renderer Process)：负责一个tab标签页的内容显示的相关工作，也称渲染引擎。
- 插件进程 (Plugin Process)：负责控制网页使用到的插件
- GPU进程 (GPU Process)：负责处理整个应用程序的GPU任务

![image-20220506112627037](https://penguinbucket.obs.cn-southwest-2.myhuaweicloud.com/img/image-20220506112627037.png)

这4个进程之间的关系是什么呢？

首先，当我们是要浏览一个网页，我们会在浏览器的地址栏里输入URL，这个时候浏览器进程的HTML内容，然后将HTML交给渲染进程，渲染进程解析HTML内容，解析遇到需要请求网络的资源又返回来交给浏览器进程进行加载，同时通知浏览器进程，需要插件进程完成后，渲染进程计算得到图像帧，并将这些图像帧交给GPU进程，GPU进程将其转化为图像显示屏幕。

![image-20220506112744244](https://penguinbucket.obs.cn-southwest-2.myhuaweicloud.com/img/image-20220506112744244.png)

## 多进程架构的优点

### 稳定性

Chrome会为每个tab标签页单独分配一个属于它们自己的渲染进程，这样即使有一个tab标签页崩溃，也不会影响到其他tab标签页的正常运行。可是如果所有的tab都跑在同一个进程的话，它们就会有连带关系，一个挂全部挂。

### 安全性和沙箱处理

浏览器会对不同进程限制不同的权限。举个例子，由于渲染进程可能会处理来自用户的随机输入，这很容易遭遇一些恶意的代码，它们会利用这些漏洞在你的电脑上安装恶意的软件，针对这一问题，浏览器限制了渲染进程读写文件的能力。

## 多进程架构的缺点

### 内存开销大

由于每个进程都有各自独立的内存空间，所以它们不能像存在于同一个进程的线程那样共用内存空间，这就造成了一些基础的架构（例如V8引擎）会在不同进程的内存空间中同时存在的问题，这些重复的内容会消耗更多的内存。所以为了节省内存，Chrome会限制被启动的进程数目，当进程数达到一定的界限后，Chrome会将**访问同一个网站的tab都放在一个进程里面跑**。

## 在浏览器地址栏输入url到显示页面，发生了什么？

上面的4个进程介绍中，可以看出浏览器进程负责了tab标签页外的大部分工作。针对不同的工作，浏览器进程划分了几个线程：

- UI线程（UI thread）：负责渲染和处理浏览器顶部按钮和地址栏等组件
- 网络线程（Network thread）：负责处理网络请求
- 存储线程（Storage thread）：控制文件的读写

### 1、处理输入

用户在浏览器地址栏输入内容时，UI线程会判断输入的内容是关键词搜索还是URL，如果是关键词搜索，则将关键词发送给搜索引擎，如果是URL，则请求URL。

![image-20220506172357010](https://penguinbucket.obs.cn-southwest-2.myhuaweicloud.com/img/image-20220506172357010.png)

### 2、开始导航

当用户按下回车后，UI线程会通知网络线程去发起网络请求获取内容。此时tab标签页的图标变为加载状态，而网络线程会进行DNS寻址、建立TSL链接等操作。

![image-20220506202328820](https://penguinbucket.obs.cn-southwest-2.myhuaweicloud.com/img/image-20220506202328820.png)

如果网络线程收到服务器响应的状态码为301重定向，那么网络线程会通知UI线程并重新发起一次请求。

### 3、读取响应

网络线程接收到服务器的响应后，开始解析HTTP报文，然后根据响应头中的`Content-Type`字段来确定响应主体的媒体类型（MIME Type），如果媒体类型是一个HTML文件，则将响应数据交给渲染进程（Renderer process）来进行下一步的工作，如果是 zip 文件或者其它文件，会把相关数据传输给下载管理器。

与此同时，浏览器会进行 [Safe Browsing](https://safebrowsing.google.com/)安全检查，如果域名或者请求内容匹配到已知的恶意站点，网络线程会展示一个警告页。除此之外，网络线程还会做[Cross-Origin Read Blocking](https://www.chromium.org/Home/chromium-security/corb-for-developers/)（CORB）检查来确定那些敏感的跨站数据不会被发送至渲染进程。

### 4、查找渲染进程

各种检查完毕以后，网络线程确认浏览器可以导航到请求网页，网络线程会通知UI线程数据已经准备好，UI线程会查找到一个渲染进程来渲染页面。

![image-20220506204741216](https://penguinbucket.obs.cn-southwest-2.myhuaweicloud.com/img/image-20220506204741216.png)

由于网络请求会花费几百毫秒时间来获取响应，浏览器为查找渲染进程这一步骤进行了优化。在第二步开始导航时，UI线程已经尝试寻找并启动渲染进程了。如果中间步骤一切顺利，当网络线程接收到数据时，渲染进程已经准备好了，但是如果遇到重定向，这个准备好的渲染进程也许就用不上了，这个时候会重新启动一个渲染进程。

### 5、提交导航

到了这一步，数据和渲染进程都已经准备就绪，浏览器进程会通过IPC通知渲染进程去提交导航。它也会传递数据流，所以渲染进程可以保持接收 HTML 数据。当浏览器进程收到渲染进程已经完成提交导航的消息时，文档加载解析阶段正式开始。

![image-20220506210448096](https://penguinbucket.obs.cn-southwest-2.myhuaweicloud.com/img/image-20220506210448096.png)

这个时候导航栏会更新，安全指示符更新（地址前面的小锁），访问历史列表（history tab）更新，即可以通过前进后退来切换该页面。

### 6、初始化加载完成

当导航提交完成后，渲染进程会开始加载资源和渲染页面。当页面渲染完毕后（页面及内部的iframe都触发了onload事件），渲染进程会通过IPC告知浏览器进程，此时UI线程将tab标签页上的加载图标隐藏。

## 浏览器的渲染原理

渲染进程负责tab标签页内发生的所有事情，它的核心工作就是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页。渲染进程内部包含了以下几个线程：

- 一个主线程（Main thread）
- 多个工作线程（Work thread）
- 一个合成器线程（Compositor thread）
- 一个光栅化线程（Raster thread）

![image-20220507100738341](https://penguinbucket.obs.cn-southwest-2.myhuaweicloud.com/img/image-20220507100738341.png)

### 1、构建DOM

当渲染进程接收到导航的确认信息并且开始接收HTML数据后，主线程开始解析文本字符串（HTML）并将其转换为[DOM](../JavaScript/介绍.md#dom)。

### 2、子资源加载

在构建DOM的过程中，会解析到图片、CSS、JavaScript脚本等资源，这些资源是需要从网络或者缓存中获取的，主线程在构建DOM过程中如果遇到了这些资源，会逐一发起请求去获取，而为了提升效率，浏览器也会运行预加载扫描（preload scanner）程序，如果HTML中存在`img`、`link`、`script`等标签，预加载扫描程序会把这些请求传递给浏览器进程的网络线程进行资源下载。

![image-20220507102814208](https://penguinbucket.obs.cn-southwest-2.myhuaweicloud.com/img/image-20220507102814208.png)

### 3、JavaScript阻塞解析

在构建DOM的过程中，如果遇到了`script`标签，渲染进程会停止解析HTML，去加载并执行JS代码。原因是JS代码可能会改变DOM的结构。（比如执行`document.write()`等API）

不过开发者也有多种方式来告知浏览器应该如何应对某个资源，比如说，如果在`<script>` 标签上添加了 `async` 或 `defer` 等属性，浏览器会异步的加载和执行JS代码，而不会阻塞渲染。

### 4、样式计算 - Style calculation

只有DOM还不去确定页面的外观，我们还需要确定每个DOM节点的样式。主线程解析 CSS 并确定每个 DOM 节点计算后的样式。

主线程会根据[CSS Selector（CSS样式选择器）](../CSS/Selectors.md)计算出每个DOM元素应该具备的具体样式，即使你的页面没有设置任何自定义的样式，浏览器也会提供其默认的样式。

![image-20220507142016754](https://penguinbucket.obs.cn-southwest-2.myhuaweicloud.com/img/image-20220507142016754.png)

### 5、布局 - Layout

DOM树和计算样式完成后，我们还需要知道每一个节点在页面上的位置，布局其实就是找到所有元素的几何关系的过程。

主线程会遍历DOM 及相关元素的计算样式，构建出包含每个元素的页面坐标信息及盒子模型大小的布局树（Render Tree），遍历过程中，会跳过隐藏的元素（display: none），另外，伪元素虽然在DOM上不可见，但是在布局树上是可见的。

![image-20220507145604062](https://penguinbucket.obs.cn-southwest-2.myhuaweicloud.com/img/image-20220507145604062.png)

### 6、绘制 - Paint

我们有了DOM结构、样式、布局，但还不足以绘制出页面。我们还需要知道每个元素的绘制顺序，在绘制阶段，主线程会遍历布局树（layout tree），生成一系列的绘画记录（paint records）。绘画记录可以看做是记录各元素绘制先后顺序的笔记。

![image-20220507150953368](https://penguinbucket.obs.cn-southwest-2.myhuaweicloud.com/img/image-20220507150953368.png)

### 7、合成 - Compositing

现在浏览器知道文档的结构、每个元素的样式、页面的几何形状和绘制顺序，它是如何绘制页面的？把这些信息转换为屏幕上的像素，我们称为光栅化。

绘制页面最简单的一个方法，就是先在光栅化视窗内的画面，如果用户滚动页面，则移动光栅框，并光栅化填充缺少的部分。这就是 Chrome 首次发布时处理光栅化的方式。

![](https://segmentfault.com/img/remote/1460000022634005)

这一方式唯一的缺点就是每当页面滚动，光栅线程都需要对新移进视图的内容进行光栅化，这是一定的性能损耗，为了优化这种情况，Chrome采取一种更加复杂的叫做合成（Compositing）的做法。

那么，什么是合成？合成是一种将**页面分成若干层**，然后分别对它们进行光栅化，最后在一个单独的线程 - 合成线程（Compositor thread）里面合并成一个页面的技术。当用户滚动页面时，由于页面各个层都已经被光栅化了，浏览器需要做的只是合成一个新的帧来展示滚动后的效果罢了。页面的动画效果实现也是类似，将页面上的层进行移动并构建出一个新的帧即可。

![](https://segmentfault.com/img/remote/1460000022634006)

为了分清哪些元素位于哪些图层，主线程会遍历布局树创建图层树（Layer Tree）。如果页面的某些部分应该是单独图层（如滑入式侧面菜单）但没拆分出来，你可以使用 CSS 中的 `will-change` 属性来提示浏览器。

![image-20220507162328805](https://penguinbucket.obs.cn-southwest-2.myhuaweicloud.com/img/image-20220507162328805.png)

你可能会想要给页面上所有的元素一个单独的层，然而当页面的层超过一定的数量后，层的合成操作要比在每个帧中光栅化页面的一小部分还要慢，因此衡量你应用的渲染性能是十分重要的一件事情。

一旦Layer Tree被创建，渲染顺序被确定，主线程会把这些信息通知给合成器线程，合成器线程开始对层次数的每一层进行光栅化。有的层的可以达到整个页面的大小，所以合成线程需要将它们切分为一块又一块的小图块（tiles），之后将这些小图块分别进行发送给一系列光栅线程（raster threads）进行光栅化，结束后光栅线程会将每个图块的光栅结果存在`GPU Process`的内存中。

![image-20220507163214647](https://penguinbucket.obs.cn-southwest-2.myhuaweicloud.com/img/image-20220507163214647.png)

合成线程会给不同的光栅线程设置优先级，以便视窗或视窗附近内的画面可以先被光栅化。图层还具有多个不同分辨率的块，可以处理放大操作等动作。

当图层上面的图块都被栅格化后，合成线程会收集图块上面叫做**绘画四边形**（draw quads）的信息来构建一个**合成帧**（compositor frame）。

- 绘画四边形：包含图块在**内存的位置**以及图层合成后图块在页面的位置之类的信息。
- 合成帧：代表页面一个帧的内容的绘制四边形**集合**。

以上所有步骤完成后，合成线程就会通过IPC向浏览器进程（browser process）提交（commit）一个渲染帧。这个时候可能有另外一个合成帧被浏览器进程的UI线程（UI thread）提交以改变浏览器的UI。这些合成帧都会被发送给GPU从而展示在屏幕上。如果合成线程收到页面滚动的事件，合成线程会构建另外一个合成帧发送给GPU来更新页面。

![image-20220507164657653](https://penguinbucket.obs.cn-southwest-2.myhuaweicloud.com/img/image-20220507164657653.png)

合成的好处在于这个过程没有涉及到主线程，所以合成线程不需要等待样式的计算以及JavaScript完成执行。这就是为什么[合成器相关的动画](https://www.html5rocks.com/en/tutorials/speed/high-performance-animations/)最流畅，如果某个动画涉及到布局或者绘制的调整，就会涉及到主线程的重新计算，自然会慢很多。

## 浏览器对事件的处理



## 参考链接

- [前端都该懂的浏览器工作原理，你懂了吗？](https://segmentfault.com/a/1190000022633988)
- [[译] 现代浏览器内部揭秘（第一部分） ](https://juejin.cn/post/6844903679389073415#heading-5)
- [[译] 现代浏览器内部揭秘（第二部分）](https://juejin.cn/post/6844903692890537992)
- [[译] 现代浏览器内部揭秘（第三部分）](https://juejin.cn/post/6844903692894732295)
- [[译] 现代浏览器内部揭秘（第四部分）](https://juejin.cn/post/6844903695600058375)

