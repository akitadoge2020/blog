## 原型和原型链

在JavaScript中，我们可以这样理解，每个实例对象都是通过 `new 构造函数()`生成的，而构造函数也是对象，因此构造函数也有属性。其中有一个prototype属性，我们称之为函数原型。

```js
// 声明一个构造函数Person
function Person(name) {
    // this指向实例
    this.name = name;
}
// 给构造函数Person的原型上添加sayMyName方法
Person.prototype.sayMyName = function() {
    console.log(`My Name is ${this.name}`);
}

// 创建实例并赋值给变量Jack
var Jack = new Person('Jack');
// 此时Jack实例继承了构造函数Person的原型上的方法与属性
Jack.sayMyName(); // output: My Name is Jack
```

默认情况下，函数原型也是一个对象，其中有一个constructor属性，就是构造函数。

```js
console.log(Person.prototype.constructor === Person); // output: true
```

另外需要补充一点，每个实例对象都有一个\__proto__属性，我们称之为隐式原型，它指向的是创建该实例的构造函数的原型

```js
console.log(Jack.__proto__ === Person.prototype); // output: true
```

但是不推荐使用这个属性，因为它不存在web标准中，随时有被删除的可能，我们更推荐使用Object.getPrototypeOf方法

```js
console.log(Object.getPrototypeOf(Jack) === Person.prototype); // output: true
```

当我们访问一个实例对象的属性时，会首先查看这个对象本身是否拥有该属性，如果没有，则会从原型中查找，如果找不到，就会从原型的原型中查找，像这样一层一层向上查找，就形成了一条原型链。

关于原型链有两种特殊情况：

- Function构造函数的隐式原型指向自身的原型

```js
console.log(Object.getPrototypeOf(Function) === Function.prototype); // output: true
```

- 所有原型链的终点是Object构造函数的原型，因此Object构造函数的原型上没有隐式原型

```js
console.log(Object.getPrototypeOf(Object)); // output: null
```

## 继承

